package org.wahlzeit.model;

import java.util.HashMap;

import static org.wahlzeit.utils.AssertionUtil.assertValidDouble;

/*
@PatternInstance(
    patternName = "ValueObject"
    participants = {
        "ValueObject"
    }
)
*/
public class SphericCoordinate extends AbstractCoordinate {
    private static final HashMap<SphericCoordinate, SphericCoordinate> allSphericCoordinates = new HashMap<>();

    private final double latitude;
    private final double longitude;
    private final double radius;

    private void assertValidRadius(double radius){
        assertValidDouble(radius);
        if(radius < 0){
            throw new IllegalArgumentException("No negative radius allowed for SphericCoordinate.");
        }
    }

    private void assertValidLongitude(double longitude) {
        assertValidDouble(longitude);
        if(longitude < -180 | longitude > 180){
            throw new IllegalArgumentException("Invalid longitude '"+longitude+"' given (must be between -180 and 180).");
        }
    }

    private void assertValidLatitude(double latitude) {
        assertValidDouble(latitude);
        if(latitude < -90 || latitude > 90){
            throw new IllegalArgumentException("Invalid latitude '"+ latitude +"' given (must be between -90 and 90).");
        }
    }

    /**
     * Creating a new SphericCoordinate from latitude, longitude and radius
     * @param latitude : Latitude in degrees
     * @param longitude : Longitude in degrees
     * @param radius: Radius in kilometer
     */
    private SphericCoordinate(double latitude, double longitude, double radius){
        assertValidRadius(radius);
        assertValidLongitude(longitude);
        assertValidLatitude(latitude);
        this.latitude = latitude;
        this.longitude = longitude;
        this.radius = radius;
    }

    public static SphericCoordinate createSphericCoordinate(double latitude, double longitude, double radius){
        SphericCoordinate newCoordinate = new SphericCoordinate(latitude, longitude, radius);
        if(allSphericCoordinates.containsValue(newCoordinate)){
            return allSphericCoordinates.get(newCoordinate);
        }
        allSphericCoordinates.put(newCoordinate, newCoordinate);
        return newCoordinate;
    }

    @Override
    public CartesianCoordinate asCartesianCoordinate() {
        double latitudeRadian = Math.toRadians(getLatitude());
        double longitudeRadian = Math.toRadians(getLongitude());

        double x = radius * Math.cos(latitudeRadian) * Math.cos(longitudeRadian);
        double y = radius * Math.cos(latitudeRadian) * Math.sin(longitudeRadian);
        double z = radius * Math.sin(latitudeRadian);

        return CartesianCoordinate.createCartesianCoordinate(x, y, z);
    }

    @Override
    public SphericCoordinate asSphericCoordinate() {
        return this;
    }

    public double getLatitude() {
        return latitude;
    }

    public double getLongitude() {
        return longitude;
    }

    public double getRadius(){
        return radius;
    }

    @Override
    public boolean equals(Object o) {
        // generated by idea
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        SphericCoordinate that = (SphericCoordinate) o;

        if (Double.compare(that.latitude, latitude) != 0) return false;
        if (Double.compare(that.longitude, longitude) != 0) return false;
        return Double.compare(that.radius, radius) == 0;
    }

    @Override
    public int hashCode() {
        // generated by idea
        int result;
        long temp;
        temp = Double.doubleToLongBits(latitude);
        result = (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(longitude);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(radius);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        return result;
    }
}
